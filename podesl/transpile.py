from __future__ import annotations

import json
from typing import Any, Dict, List

HEADER = """# Auto-generated by podesl.transpile
from podesl.runtime import eval_expr, report_print, report_export_csv, report_plot
from podesl.dispatcher import dispatch
from podesl.execution import store_last_run
"""


def _emit_eval(expr: str, allow_result: bool = False) -> str:
    quoted = json.dumps(expr)
    if allow_result:
        return f"eval_expr({quoted}, env, result)"
    return f"eval_expr({quoted}, env)"


def transpile(ast: Dict[str, Any]) -> str:
    code: List[str] = [HEADER, "def main():"]
    problem = ast.get("problem") or {}
    code.append(f"    problem = {json.dumps(problem)}")
    code.append("    env = {}")

    for block in ast.get("blocks", []):
        btype = block.get("type")
        if btype not in {"given", "solve", "equations"}:
            continue
        for stmt in block.get("stmts", []):
            kind = stmt.get("kind")
            line = stmt.get("line")
            if kind == "assign":
                expr = stmt.get("value", "")
                if not expr:
                    raise ValueError(f"Empty expression in assignment at line {line}")
                name = stmt.get("name")
                code.append(f"    env['{name}'] = {_emit_eval(expr)}")
            elif btype == "equations" and kind == "command":
                if stmt.get("name") != "eq":
                    raise ValueError(
                        f"Unsupported command '{stmt.get('name')}' in EQUATIONS block (line {line})."
                    )
                args = stmt.get("args") or []
                if not args:
                    raise ValueError(f"EQUATIONS eq command missing argument at line {line}")
                code.append(
                    f"    env.setdefault('equations', []).append({_emit_eval(args[0])})"
                )
            elif kind == "command":
                raise ValueError(
                    f"Commands are not allowed in {btype.upper()} block (line {line})."
                )

    code.append("    result = dispatch(problem, env)")
    code.append("    store_last_run(problem, env, result)")
    printed = False

    for block in ast.get("blocks", []):
        if block.get("type") != "report":
            continue
        for stmt in block.get("stmts", []):
            if stmt.get("kind") != "command":
                continue
            name = stmt.get("name")
            args = stmt.get("args") or []
            if name == "print":
                if args:
                    arg_code = ", ".join(_emit_eval(arg, allow_result=True) for arg in args)
                    code.append(f"    report_print({arg_code})")
                else:
                    code.append("    report_print(result)")
                printed = True
            elif name == "export":
                if not args:
                    continue
                path = _emit_eval(args[0], allow_result=True)
                values = ", ".join(_emit_eval(arg, allow_result=True) for arg in args[1:])
                if values:
                    code.append(f"    report_export_csv({path}, {values})")
                else:
                    code.append(f"    report_export_csv({path})")
            elif name == "plot":
                if not args:
                    continue
                arg_code = ", ".join(_emit_eval(arg, allow_result=True) for arg in args)
                code.append(f"    report_plot({arg_code})")
                printed = True
            else:
                raise ValueError(f"Unknown REPORT command '{name}' at line {stmt.get('line')}")

    if not printed:
        code.append("    return result")
    code.append("")
    code.append("if __name__ == '__main__':")
    code.append("    main()")
    return "\n".join(code)
